#!/usr/bin/env python
# Time-stamp: <2025-08-01 12:08:55 Shengen Hu>
 
"""Description: software package for "PATTY: corrects open chromatin bias for improved bulk and single-cell CUT&Tag profiling"
Copyright (c) 2025 Shengen Hu <tarelahu@gmail.com>
This code is free software; you can redistribute it and/or modify it
under the terms of the BSD License (see the file COPYING included with
the distribution).
@status: release candidate
@version: $Id$
@author:  Shengen Hu
@contact: tarelahu@gmail.com
"""

# ------------------------------------
# python modules
# ------------------------------------

import os
import sys
import time
import string
from optparse import OptionParser
import subprocess
import time

# ------------------------------------
# own python modules
# ------------------------------------

### tool function
from PATTYpipe.Utility import (sp,
                    raise_error,
                    wlog,
                    CMD
                    )
                                   
# -------------------
# main step
# -------------------

from PATTYpipe.step0_check_data import step0_check_data
from PATTYpipe.step1_BULKscanSig import step1_BULKscanSig
from PATTYpipe.step1_SCscanSig import step1_SCscanSig
from PATTYpipe.stepFinal_summary import stepFinal_summary

# ------------------------------------
# read in parameters
# ------------------------------------

def main():
    '''
    Read parameter 
    '''
    usage = "%prog -m bulk -a CUTTag.bed -a ATAC -f H3K27me3 -g hg38 -o outname "
    description = """PATTY: a computational method for correcting open chromatin bias in bulk and single-cell CUT&Tag data"""

    optparser = OptionParser(version="%prog 1.0.0",description=description,usage=usage,add_help_option=False)
    optparser.add_option("-h","--help",action="help",help="Show this help message and exit.")

#========major options=============
    optparser.add_option("-m","--mode",dest="mode",type="choice",choices=("sc","bulk"),
                             help = "[required] Mode of PATTY, choose from bulk or sc(single-cell)")
    optparser.add_option("-c","--cuttag", dest = 'cuttag',type="str",
                             help = "[required] CUTTAG Input fragments file in (paired/single end) bed format for CUT&Tag data, with .bed extension (or .bed.gz for comparessed file). For sc mode, the 4th(name) column of the bed file represents the name/barcode of the corresponding individual cell" )
    optparser.add_option("-a","--atac", dest = 'atac',type="str", 
                             help = "[required] ATAC Input fragments file in bed format for ATAC-seq data, with .bed extension(or .bed.gz for comparessed file). The ATAC-seq fragments were used as bulk data for both sc and bulk modes (only chrm,start,end 3columns are required)" )
    optparser.add_option("-f","--factor",dest='factor',type="choice",choices=("H3K27me3","H3K27ac","H3K9me3"),
                             help = "[required] FACTOR Factor type of the CUT&Tag data. Currently PATTY support H3K27me3, H3K27ac, and H3K9me3" )
    optparser.add_option("-g","--genome",dest="genome",type="choice",choices=("hg38","mm10"),
                             help = "[required] genome version, currently support hg38 and mm10.")
    optparser.add_option("-b","--genomebin",dest='genomebin',type="str",
                             help = "[required] genome-wide mappable bin file. The bin file annotation for supported genome (hg38/mm10) is pre-defined and provided." )
    optparser.add_option("-o","--outname", dest="outname",type="str",
                             help = "[required] Name of output results" )

#========minor options============= 
    optparser.add_option("--binList",dest="binlist",type="str",
                         help="[optional] Bed file for inputting candidate bins/peaks for the analysis. When inputted, the correction will be done on only these bins, otherwise the correction will be done on genome mappable bins (specified by -b). This parameter is designed for customized high-reads bin (bulk mode) or high-var bin (sc mode). The inputed peaks/bins will be transformed/splited to 200bp bins for as the input. The genome version of the binlist bed file should be hg38 or mm10.")
    optparser.add_option("--cellnames",dest="cellnames",type="str",
                         help="[sc optional] Single column file for name list of used individual cells, each line contain the name of the individual cell. This parameter is only used for sc mode")
    optparser.add_option("--readCutoff",dest="readcutoff",type="int",default=100,
                         help="[sc optional] Reads number cutoff for high quality cells. Cells with < 100(default) reads will be discarded in the analysis. This parameter is only used for sc mode")
    optparser.add_option("--overwrite",dest='fover',  default=False, action='store_true', 
                         help = "[optional] Force overwrite, this cmd will remove existing result if set !! " )
    optparser.add_option("--keeptmp",dest='keeptmp',  default=False, action='store_true', 
                         help = "[optional] whether or not keep the intermediate results (tmpResults)" )

    (options,args) = optparser.parse_args()

    if not options.mode:
        optparser.print_help()
        print('PATTY mode (-m) is required ')
        sys.exit(1)

    if not options.cuttag:
        optparser.print_help()
        print('Input cuttag file (-c) is required ')
        sys.exit(1)

    if not options.atac:
        optparser.print_help()
        print('Output atac name (-a) is required ')
        sys.exit(1)

    if not options.factor:
        optparser.print_help()
        print('factor type (-f) is required ')
        sys.exit(1)

    if not options.genome:
        optparser.print_help()
        print('genome version (-g) is required ')
        sys.exit(1)

    if not options.genomebin:
        optparser.print_help()
        print('genome bin file (-b) is required ')
        sys.exit(1)

    if not options.outname:
        optparser.print_help()
        print('outname (-o) is required ')
        sys.exit(1)

    conf_dict = {}
    conf_dict['General'] = {}
    conf_dict['options'] = {}
    ## major param
    conf_dict['General']['mode'] = options.mode
    conf_dict['General']['cuttag'] = options.cuttag
    conf_dict['General']['atac'] = options.atac
    conf_dict['General']['factor'] = options.factor
    conf_dict['General']['genome'] = options.genome
    conf_dict['General']['genomebin'] = options.genomebin
    conf_dict['General']['outname'] = options.outname

    ## minor option
    conf_dict['options']['keeptmp'] = options.keeptmp
    # bulk option
    conf_dict['options']['binlist'] = options.binlist
    # sc option
    conf_dict['options']['cellnames'] = options.cellnames
    conf_dict['options']['readcutoff'] = options.readcutoff
    #conf_dict['options']['clustermethod'] = options.clustermethod
    #conf_dict['options']['clusterNum'] = options.clusterNum    
    #conf_dict['options']['topDim'] = options.topDim    
    #conf_dict['options']['UMAP'] = options.UMAP 

    ### read raw path of output dir, the startdir will be used when the input file is not in absolute path
    conf_dict['General']['startdir'] = os.getcwd()+'/'

    ### check parameters: 
    if "~" in conf_dict['General']['outname']:
        print('ERROR: ~ cannot appeared in outname, current outname is %s'%(conf_dict['General']['outname']))
        sys.exit(1)
    if "/" in conf_dict['General']['outname']:
        print('ERROR: / cannot appeared in outname, current outname is %s'%(conf_dict['General']['outname']))
        sys.exit(1)
    
    ### creat output dir
    if os.path.isfile(conf_dict['General']['outname']):
        print('ERROR: name of your output dir %s is exist as a file, cannot create a dir, exit'%(conf_dict['General']['outname']))
        sys.exit(1)
    elif os.path.isdir(conf_dict['General']['outname']):
        if not options.fover:
            print('ERROR: name of your output dir is exist as a dir, exit because overwrite function is turned off, you can add --overwrite parameter to turn on overwrite function')
            sys.exit(1)
        else: 
            print('name of your output dir is exist as a dir, overwrite is turned on, write output result in existing dir')
    else:
        os.system("mkdir %s"%(conf_dict['General']['outname']))

    ### move to output dir
    os.chdir(conf_dict['General']['outname'])
    ### specify the main progress log file
    logfile = conf_dict['General']['outname']+'_progress.log'
    ### remove existing log file. 
    if os.path.isfile(logfile):
        if options.fover:
            CMD('rm %s'%logfile)
            print('process log is printed into %s'%(logfile))
        else:
            logfile_orig = logfile
            logfile += str(time.time())
            print('process log is printed into %s, because %s exists and overwrite function is turned off'%(logfile,logfile_orig))
    else:
        print('process log is printed into %s'%(logfile))

    conf_dict['QC'] = {}
    conf_dict['results'] = {}

    wlog("Start PATTY %s mode"%(conf_dict['General']['mode']),logfile)
    wlog("check input Data and parameters",logfile)   
    step0_check_data(conf_dict,logfile)
    #wlog('check input Data and parameters DONE',logfile)

    if conf_dict['General']['mode'] == "bulk":
        # bulk bias
        t = time.time()
        wlog('bulk correction',logfile)
        step1_BULKscanSig(conf_dict,logfile)
        step1time = time.time() -t
        wlog("running time for: bulk correction, %s"%(step1time),logfile)

    else:
        # sc bias
        t = time.time()
        wlog('single-cell scan signal',logfile)
        step1_SCscanSig(conf_dict,logfile)
        step1time = time.time() -t
        wlog("running time for: single-cell correction, %s"%(step1time),logfile)

        #t = time.time()
        #wlog('Step2: single-cell bias correction',logfile)
        #step2_SCcorrect(conf_dict,logfile)
        #step2time = time.time() -t
        #wlog("running time for Step2: single-cell bias correction, %s"%(step2time),logfile)

        ## sc clustering
        #t = time.time()
        #wlog('Step3: single-cell clustering',logfile)
        #step3_SCcellClustering(conf_dict,logfile)
        #step3time = time.time() -t
        #wlog("running time for Step3: single-cell clustering %s"%(step3time),logfile)

    # summary
    #t = time.time()
    #wlog('StepFinal: summary',logfile)
    stepFinal_summary(conf_dict,logfile)
    #stepFtime = time.time() -t
    #wlog("running time for StepFinal: summary %s"%(stepFtime),logfile)

    if conf_dict['General']['mode'] == "bulk" and os.path.isfile("%s_correctSig.bw"%(conf_dict['General']['outname'])):
        wlog('bulk mode Done, check %s_correctSig.bw as bias-corrected signal'%(conf_dict['General']['outname']),logfile)
    if conf_dict['General']['mode'] == "sc" and os.path.isfile("%s_correctMat.txt"%(conf_dict['General']['outname'])):
        wlog('sc mode Done, check %s_correctMat.txt as bias-corrected matrix'%(conf_dict['General']['outname']),logfile)
#    wlog("PATTY finished. Check the folder: %s/summary/ for results"%(conf_dict['General']['outname']),logfile)

if __name__== '__main__':
    try:
        main()

    except KeyboardInterrupt:
        sys.stderr.write("User interrupt me >.< \n")
        sys.exit(0)